package com.mp5a5.dynamic;

/**
 * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
 * 示例:
 * <p>
 * 输入: [-2,1,-3,4,-1,2,1,-5,4],
 * 输出: 6
 * 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
 */
public class MaxPrefaceSum {

    /**
     * 问题拆解：
     * <p>
     * 问题的核心是子数组，子数组可以看作是一段区间，因此可以由起始点和终止点确定一个子数组，两个点中，我们先确定一个点，然后去找另一个点，比如说，如果我们确定一个子数组的截止元素在 i 这个位置，这个时候我们需要思考的问题是 “以 i 结尾的所有子数组中，和最大的是多少？”，然后我们去试着拆解，这里其实只有两种情况：
     * <p>
     * i 这个位置的元素自成一个子数组;
     * <p>
     * i 位置的元素的值 + 以 i - 1 结尾的所有子数组中的子数组和最大的值
     * <p>
     * 你可以看到，我们把第 i 个问题拆成了第 i - 1 个问题，之间的联系也变得清晰
     * <p>
     * 状态定义:
     * <p>
     * 通过上面的分析，其实状态已经有了，dp[i] 就是 “以 i 结尾的所有子数组的最大值”
     * <p>
     * 递推方程:
     * <p>
     * 拆解问题的时候也提到了，有两种情况，即当前元素自成一个子数组，另外可以考虑前一个状态的答案，于是就有了
     * <p>
     * dp[i] = Math.max(dp[i - 1] + array[i], array[i])
     * 化简一下就成了：
     * <p>
     * dp[i] = Math.max(dp[i - 1], 0) + array[i]
     * <p>
     * 实现:
     * <p>
     * 题目要求子数组不能为空，因此一开始需要初始化，也就是 dp[0] = array[0]，保证最后答案的可靠性，另外我们需要用一个变量记录最后的答案，因为子数组有可能以数组中任意一个元素结尾
     */
    public int maxSubArray(int[] nums) {

        if (nums == null || nums.length == 0) return 0;

        int len = nums.length;

        int[] dp = new int[len];

        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < len; i++) {
            dp[i] = Math.max(dp[i - 1], 0) + nums[i];
            result = Math.max(result, dp[i]);
        }
        return result;
    }
}
